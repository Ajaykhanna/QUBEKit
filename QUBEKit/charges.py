#!/usr/bin/env python3

# TODO
#  Dipole and quadrupole stuff
#  UNITS - Change spherical coord units rather than xyz coord units for fewer FlOps overall
#  Improved graphing; contour plot?

from QUBEKit.utils.helpers import extract_charge_data

from matplotlib import pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np


class Charges:

    def __init__(self, molecule):

        self.molecule = molecule

        self.ddec_data, self.dipole_moment_data, self.quadrupole_moment_data = extract_charge_data(self.molecule.ddec_version)

        # List of tuples where each tuple is the xyz atom coords, followed by their partial charge
        self.atom_points = []
        # List of tuples where each tuple is the xyz esp coords, followed by the esp value
        self.esp_points = []

        self.generate_esp_data_molecule()
        self.plot()

    @staticmethod
    def spherical_to_cartesian(r, theta, phi):
        """
        :return: (x, y, z) coords from the spherical (r, theta, phi) coords.
        """
        return r * np.sin(theta) * np.cos(phi), r * np.sin(theta) * np.sin(phi), r * np.cos(theta)

    @staticmethod
    def monopole_esp(q, r):
        """
        :params: charge, q at a distance, r
        :return: esp at a point, distance r from a charge, q
        """
        return q / (4 * np.pi * r)

    @staticmethod
    def dipole_esp(q1, q2, r1, r2):
        """
        :params: dipole charges and respective distances from charges to esp measurement point
        :return: esp at a point generated by dipole charges q1, q2 at distances r1, r2
        """
        return

    @staticmethod
    def quadrupole_moment_tensor(q_xy, q_xz, q_yz, q_x2_y2, q_3z2_r2):
        """
        :params: quadrupole moment components from Chargemol output
        :return: quadrupole moment tensor, M
        """
        return np.array([
            [q_x2_y2 / 2 - q_3z2_r2 / 6, q_xy, q_xz],
            [q_xy, -q_x2_y2 / 2 - q_3z2_r2 / 6, q_yz],
            [q_xz, q_yz, q_3z2_r2 / 3]
        ])

    @staticmethod
    def quadrupole_esp(r, m_tensor):
        return (3 * r.dot(m_tensor).dot(r)) / (2 * r ** 5)

    def generate_esp_data_atom(self, charge):
        """
        Using a few constraints to determine the density and distribution of points,
        generate a list of points with their ESP at that point.
        :return: points; this is a list of tuples where each tuple is an x,y,z coord followed by the ESP at that point
        This can then be used to colour the point with matplotlib
        """

        # TODO Generalise and update to include dipoles and quadrupoles.

        # The innermost shell will have 16 points
        min_points_per_shell = 16
        shells = 6

        points = []
        for shell in range(shells):
            # (* shell) scales the number of points per shell by the radius squared.
            # This creates a more uniform sparsity
            points_in_shell = min_points_per_shell * shell
            for theta in range(points_in_shell):
                for phi in range(points_in_shell):
                    points.append((
                        *self.spherical_to_cartesian(
                            (shell + 1) * 0.3,
                            (theta / points_in_shell) * 2 * np.pi,
                            (phi / points_in_shell) * 2 * np.pi),
                        self.monopole_esp(charge, shell + 1)
                    ))
        return points

    def generate_esp_data_molecule(self):
        """
        Fill esp_points list; this is a list of tuples where each tuple is an xyz coord followed by the ESP at that point.
        This can then be used to colour the point with matplotlib.
        The list of esp_points is for all atoms in self.molecule.
        """

        for coord, atom in zip(self.molecule.coords['input'], self.molecule.atoms):
            # Add the atoms themselves to a separate list to be plotted
            self.atom_points.append((*coord, atom.partial_charge))
            # Generate the esp data (not centred on the atoms)
            centred_points = self.generate_esp_data_atom(atom.partial_charge)
            for point in centred_points:
                # Whatever the coordinates of the ESPs are, add them to the atoms' coords to properly position them
                # colour (point[3]) remains unchanged
                self.esp_points.append((point[0] + coord[0], point[1] + coord[1], point[2] + coord[2], point[3]))

    def plot(self):
        """
        Plot the atoms of a molecule with large crosses; colour is given by their partial charge.
        Then, plot the esp at all of the sample points with small dots; colour is given by the esp magnitude.
        """

        fig = plt.figure()
        ax = fig.add_subplot(111, projection=Axes3D.name)

        ax.scatter(
            xs=[i[0] for i in self.esp_points],
            ys=[i[1] for i in self.esp_points],
            zs=[i[2] for i in self.esp_points],
            c=[i[3] for i in self.esp_points],
            marker='o',
            s=1,
            alpha=0.1
        )

        ax.scatter(
            xs=[i[0] for i in self.atom_points],
            ys=[i[1] for i in self.atom_points],
            zs=[i[2] for i in self.atom_points],
            c=[i[3] for i in self.atom_points],
            marker='X',
            s=100
        )

        plt.show()
